/**
 * Defines postprocessors on Markdown content.
 */

import type { MarkdownPostProcessorContext, WorkspaceLeaf } from 'obsidian';
import { MarkdownRenderChild } from 'obsidian';
import * as _ from 'lodash';

import type CitationService from './citation-service';
import type CitationPlugin from './main';
import type { Entry } from './types';
import Bibliography from './ui/Bibliography.svelte';

/**
 * Replaces citations with inline references generated by citeproc.
 */
export class InlineCitationRenderer extends MarkdownRenderChild {
  constructor(containerEl: HTMLElement, private plugin: CitationPlugin) {
    super(containerEl);

    this.registerEvent(
      this.plugin.events.on('library-load-complete', () => this.render()),
    );
  }

  onload(): void {
    this.render();
  }

  render(): void {
    if (!this.plugin.library) return;

    // TODO handle chain of references
    // TODO handle pandoc format
    this.containerEl.querySelectorAll('a.internal-link').forEach((link) => {
      if (!(link instanceof HTMLAnchorElement)) return;

      const match = link.pathname.match(/^\/(@(.+))$/);
      if (match) {
        const [, fullMatch, citekey] = match;
        const entry = this.plugin.library.entries[citekey];
        if (entry) {
          // Render inline citation.
          const citation = this.plugin.citationService.renderCitation(
            citekey,
            true,
          );
          if (citation.includes('NO_PRINTED_FORM')) {
            // Error in generating citation. Quit.
            return;
          }

          link.innerHTML = link.innerHTML.replace(fullMatch, citation);
          link.addClass('citation-link');
        }
      }
    });
  }
}

/**
 * Renders bibliography section within the document.
 */
export class BibliographyRenderer extends MarkdownRenderChild {
  service: CitationService;
  view: Bibliography;

  constructor(
    private ctx: MarkdownPostProcessorContext,
    private sourceText: string,
    containerEl: HTMLElement,
    private plugin: CitationPlugin,
  ) {
    super(containerEl);

    this.registerEvent(
      this.plugin.events.on('library-load-complete', () => this.render()),
    );

    this.service = this.plugin.citationService;
  }

  onload(): void {
    this.view = new Bibliography({
      target: this.containerEl,
      props: {
        citations: [],
      },
    });

    this.render();
  }

  // DEV duplicated from view.ts
  async getCitations(content: string): Promise<[Entry, string, string[]][]> {
    const results = this.plugin
      .extractCitations(content)
      .filter(([entry]) => !!entry);
    const groupedResults = _.groupBy(results, ([entry]) => entry.id);
    const uniqueIds = Object.keys(groupedResults);

    // Render bibliography strings with citation service.
    const [, bibStrings] = this.service.renderBibliography(uniqueIds);
    const bibStringMap = Object.fromEntries(_.zip(uniqueIds, bibStrings));

    return Object.values(groupedResults).map((occurrences) => {
      const entry = occurrences[0][0];
      const bibString = bibStringMap[entry.id];
      const occurrenceStrings = occurrences.map(([, line]) => line);
      return [entry, bibString, occurrenceStrings];
    });
  }

  async render(): Promise<void> {
    if (!this.view) return;

    if (this.plugin.isLibraryLoading) {
      this.view.$set({ citations: null, loading: true });
    } else {
      // DEV how do we do this cleanly?
      const data: string = await this.plugin.app.vault.adapter.read(
        this.ctx.sourcePath,
      );
      const citations = await this.getCitations(data);

      // TODO add backlinks to bibliography; use `MarkdownPreviewView#applyScroll`

      this.view.$set({ citations, loading: false });
    }
  }
}
